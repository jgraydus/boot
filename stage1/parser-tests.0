(import "parser.0")

((fn ()
    (define s (cs-from-string "abc"))
    (define next (cs-next s))
    (assert (= "a" (head next)) "first character of stream is 'a'")

    (set! s (nth 1 next))
    (set! next (cs-next s))
    (assert (= "b" (head next)) "second character of stream is 'b'")

    (set! s (nth 1 next))
    (set! next (cs-next s))
    (assert (= "c" (head next)) "third character of stream is 'c'")

    (set! s (nth 1 next))
    (set! next (cs-next s))
    (assert (nil? next) "stream is empty")
))

((fn ()
   (define s (cs-from-string ""))
   (define next (cs-next s))
   (assert (nil? next) "empty string is empty")
))

((fn ()
   (define s (cs-from-string "abcdefg"))
   (define next (cs-take-n 3 s))
   (assert (= "abc" (head next)) "first three characters of stream are 'abc'")

   (set! s (nth 1 next))
   (set! next (cs-take-n 3 s))
   (assert (= "def" (head next)) "second three characters of stream are 'def'")

   (set! s (nth 1 next))
   (set! next (cs-take-n 100 s))
   (assert (= "g" (head next)) "when n exceeds remaining characters, return all remaining chars")

   (set! s (nth 1 next))
   (set! next (cs-take-n 100 s))
   (assert (= "" (head next)) "result is empty string when no characters left")
))

((fn ()
   (define s (cs-from-string ""))
   (define next (cs-take-n 100 s))
   (assert (= "" (head next)) "result is empty string when input is empty string")
))

((fn ()
    (define s (cs-from-string "foo"))
    (define r ((success 42) cs))
    (assert (= (list (quote success) 42 cs) r) "success")

    (assert (nil? (failure)) "failure")
))

((fn ()
   (define foobar (cs-from-string "foobar"))
   (define result ((parse-string "foo") foobar))
   (assert (success? result) "the parse is a success")
   (assert (= "foo" (success-value result)) "result of parsing 'foo' is 'foo'")
   (assert (= (list "foobar" 3 4 1) (nth 2 result)) "")
   (set! result ((parse-string "bar") (success-cs result)))
   (assert (success? result) "the parse is a success")
   (assert (= "bar" (success-value result)) "result of parsing 'bar' is 'bar'")
))

((fn ()
   (define foobar (cs-from-string "foobar"))
   (define parse-foobar (parse-both (parse-string "foo") (parse-string "bar")))
   (define result (parse-foobar foobar))
   (assert (success? result) "parse is a success")
   (assert (= (list "foo" "bar") (success-value result)) "result is 'foo' and 'bar'")
))

((fn ()
   (define foo (cs-from-string "foo"))
   (define bar (cs-from-string "bar"))
   (define parser (parse-either (parse-string "foo") (parse-string "bar")))

   (define result (parser foo))
   (assert (success? result) "parse is a success")
   (assert (= "foo" (success-value result)) "result is 'foo'")

   (set! result (parser bar))
   (assert (success? result) "parse is a success")
   (assert (= "bar" (success-value result)) "result is 'bar'")
))

((fn ()
   (define foo (cs-from-string "foo"))
   (define parser (parse-map (const 42) (parse-string "foo")))
   (define result (parser foo))
   (assert (success? result) "")
   (assert (= 42 (success-value result)) "result is 42") 
))

((fn ()
   (define foobarbaz (cs-from-string "foobarbaz"))
   (define parser (parse-sequence (list (parse-string "foo") (parse-string "bar") (parse-string "baz"))))
   (define result (parser foobarbaz))
   (assert (success? result) "")
   (assert (= (list "foo" "bar" "baz") (success-value result)) "result is 'foo', 'bar', and 'baz'")
))

((fn ()
   (define baz (cs-from-string "baz"))
   (define parser (parse-one-of (list (parse-string "foo") (parse-string "bar") (parse-string "baz"))))
   (define result (parser baz))
   (assert (success? result) "")
   (assert (= "baz" (success-value result)) "result is 'baz'")
))

((fn ()
   (define foo3 (cs-from-string "foofoofoo"))
   (define parser (parse-many (parse-string "foo")))
   (define result (parser foo3))
   (assert (success? result) "")
   (assert (= (list "foo" "foo" "foo") (success-value result)) "result is 'foo', 'foo', and 'foo'")
))

((fn ()
   (define foo3 (cs-from-string "foofoofoo"))
   (define parser (parse-many (parse-string "bar")))
   (define result (parser foo3))
   (assert (success? result) "")
   (assert (nil? (success-value result)) "result is nil")
))

((fn ()
   (define foo3 (cs-from-string "foofoofoo"))
   (define parser (parse-at-least-one (parse-string "foo"))) 
   (define result (parser foo3))
   (assert (success? result) "")
   (assert (= (list "foo" "foo" "foo") (success-value result)) "result is 'foo', 'foo', and 'foo'")
))

((fn ()
   (define barbazfoo (cs-from-string "barbazfoo"))
   (define parser (parse-zero-or-one (parse-string "foo"))) 
   (define result (parser barbazfoo))
   (assert (success? result) "")
   (assert (nil? (success-value result)) "result is nil")
))

((fn ()
   (define foobarbaz (cs-from-string "foobarbaz"))
   (define parser (parse-zero-or-one (parse-string "foo"))) 
   (define result (parser foobarbaz))
   (assert (success? result) "")
   (assert (= "foo" (success-value result)) "result is 'foo'")
))

((fn ()
   (define space " ")
   (define tab (chr 9))
   (define newline (chr 10))

   (define result (parse-whitespace (cs-from-string space)))
   (assert (success? result) "")
   (set! result (parse-whitespace (cs-from-string tab)))
   (assert (success? result) "")
   (set! result (parse-whitespace (cs-from-string newline)))
   (assert (success? result) "")

   (set! result (parse-optional-whitespace (cs-from-string "foo")))
   (assert (success? result) "")
   (set! result (parse-required-whitespace (cs-from-string "foo")))
   (assert (not (success? result)) "whitespace is required")
   (set! result (parse-required-whitespace (cs-from-string " foo")))
   (assert (success? result) "")
))

((fn ()
   (define result (parse-ascii-A-to-Z (cs-from-string "A")))
   (assert (success? result) "")
   (set! result (parse-ascii-A-to-Z (cs-from-string "Z")))
   (assert (success? result) "")
   (set! result (parse-ascii-A-to-Z (cs-from-string "P")))
   (assert (success? result) "")
   
   (set! result (parse-ascii-a-to-z (cs-from-string "a")))
   (assert (success? result) "")
   (set! result (parse-ascii-a-to-z (cs-from-string "z")))
   (assert (success? result) "")
   (set! result (parse-ascii-a-to-z (cs-from-string "p")))
   (assert (success? result) "")
   
   (set! result (parse-alpha (cs-from-string "A")))
   (assert (success? result) "")
   (set! result (parse-alpha (cs-from-string "Z")))
   (assert (success? result) "")
   (set! result (parse-alpha (cs-from-string "P")))
   (assert (success? result) "")
   (set! result (parse-alpha (cs-from-string "a")))
   (assert (success? result) "")
   (set! result (parse-alpha (cs-from-string "z")))
   (assert (success? result) "")
   (set! result (parse-alpha (cs-from-string "p")))
   (assert (success? result) "")

   (set! result (parse-ascii-digit (cs-from-string "0")))
   (assert (success? result) "")
   (set! result (parse-ascii-digit (cs-from-string "1")))
   (assert (success? result) "")
   (set! result (parse-ascii-digit (cs-from-string "2")))
   (assert (success? result) "")
   (set! result (parse-ascii-digit (cs-from-string "9")))
   (assert (success? result) "")

   (set! result (parse-ascii-non-zero-digit (cs-from-string "0")))
   (assert (not (success? result)) "0 is not non-zero")
   (set! result (parse-ascii-non-zero-digit (cs-from-string "1")))
   (assert (success? result) "1 is non-zero")
   (set! result (parse-ascii-non-zero-digit (cs-from-string "9")))
   (assert (success? result) "9 is non-zero")

   (set! result (parse-alphanum (cs-from-string "A")))
   (assert (success? result) "")
   (set! result (parse-alphanum (cs-from-string "z")))
   (assert (success? result) "")
   (set! result (parse-alphanum (cs-from-string "0")))
   (assert (success? result) "")
   (set! result (parse-alphanum (cs-from-string "9")))
   (assert (success? result) "")
))

((fn ()
   (define result (parse-double-quotes (cs-from-string (chr 34))))
   (assert (success? result) "")
))

((fn ()
   (assert (not (any ())) "any is false for empty list")
   (assert (any (list #f #f #f #t #f #f)) "any")
   (assert (not (any (list #f #f #f))) "not any")

   (assert (all ()) "all is true for empty list")
   (assert (not (all (list #t #t #t #f #t #t))) "not all")
   (assert (all (list #t #t #t #t)) "all")
))

((fn ()
   (assert (= "" (list-to-string nil)) "empty list = ")
   (assert (= "foobar" (list-to-string (list "f" "o" "o" "b" "a" "r"))) "foobar = foobar")
))

((fn ()
   (define result (parse-identifier (cs-from-string "foo!@#$bar kjaslkdjf")))
   (assert (success? result) "")
   (assert (= "foo!@#$bar" (success-value result)) "")
))

((fn ()
   (define s (cs-from-string "()"))
   (define r (parse-param-list s))
   (assert (success? r) "() is a valid param list")
   (assert (= (list (quote formal-params) () ()) (success-value r)) "() is an empty param list")

   (set! s (cs-from-string "(foo)"))
   (set! r (parse-param-list s))
   (assert (success? r) "(foo) is a valid param list")
   (assert (= (list (quote formal-params) (list "foo") ()) (success-value r)) "(foo)")

   (set! s (cs-from-string "( foo bar )"))
   (set! r (parse-param-list s))
   (assert (success? r) "( foo bar ) is a valid param list")
   (assert (= (list (quote formal-params) (list "foo" "bar") ()) (success-value r)) "( foo bar )")

   (set! s (cs-from-string "(foo bar & rest)"))
   (set! r (parse-param-list s))
   (assert (success? r) "(foo bar & rest) is a valid param list")
   (assert (= (list (quote formal-params) (list "foo" "bar") "rest") (success-value r)) "(foo bar & rest)")
))

((fn ()
   (assert (= 0 (char-string-to-int nil)) "() = 0")
   (assert (= 12345 (char-string-to-int (list "1" "2" "3" "4" "5"))) "12345 = 12345")

   (define s (cs-from-string "12345"))
   (define r (parse-integer-exp s))
   (assert (success? r) "12345 is an integer")
   (assert (= (list (quote integer-exp) 12345) (success-value r)) "12345 = 12345")

   (set! s (cs-from-string "01234"))
   (set! r (parse-integer-exp s))
   (assert (not (success? r)) "01234 not valid integer")
))

((fn ()
   (define str1 "abc123 !@#$%^&*()-=_+,./<>?[]\{}|")
   (define str (list-to-string (list double-quote str1 double-quote)))
   (define s (cs-from-string str))
   (define r (parse-string-exp s))
   (assert (success? r) "valid string")
   (assert (= (list (quote string-exp) str1) (success-value r)) "valid string exp")
))

((fn ()
   (define s (cs-from-string "12345"))
   (define r (parse-exp s))
   (assert (success? r) "12345 is an expression")
   (assert (= (list (quote integer-exp) 12345) (success-value r)) "")

   (set! s (cs-from-string "(define x 12345)"))
   (set! r (parse-exp s))
   (assert (success? r) "integer exp")
   (assert (= (list (quote define-exp) "x" (list (quote integer-exp) 12345)) (success-value r)) "")

   (set! s (cs-from-string "foobar"))
   (set! r (parse-exp s))
   (assert (success? r) "identifier exp")
   (assert (= (list (quote id-exp) "foobar") (success-value r)) "identifier exp value")

   (set! s (cs-from-string (list-to-string (list double-quote "foo" double-quote))))
   (set! r (parse-exp s))
   (assert (success? r) "string exp")
   (assert (= (list (quote string-exp) "foo") (success-value r)) "string exp value")

   (set! s (cs-from-string "(fn () body)"))
   (set! r (parse-exp s))
   (assert (success? r) "0-arity fn")
   (assert (= (list (quote fn-exp) (list (quote formal-params) () ()) "body") (success-value r)) "0-arity fn value")
))





